let ckt = load_exe "XORMultiPortMemory16.exe";
load "gsteSymReduce.fl";
loadModel ckt;

let isI addrV i=
    let ADDR_SIZE = length addrV in 
    let ivec = ind2Addr i ADDR_SIZE in
    let terms = map2 (\a. \iv. iv=bT =>  a | bNOT a) addrV ivec in
    itlist (\t.\pre. (t bAND pre)) terms bT
;

let addrIs adr n= 
    let size = length adr 
    in
	letrec tobool n size=
		(size = 0) => []
		| (n%2): (tobool (n/2) (size-1)) 
    in
	TAndList (map2 (\i.\j. (i=0) => (Is0 (el (j+1) adr)) | (Is1 (el (j+1) adr))) (tobool n size) (0 upto (size-1)))
;

//universal STE
let uSTE option model weak ant cons trace_list constraints =
    constraints = [] => (
       STE option model weak ant cons trace_list
    ) | (
        let all_cnstr = itlist (\c.\pre. c bAND pre) constraints bT in
        let cnstr_bdd = hd (bexpr2bdd [] [all_cnstr]) in
        cSTE ([], [cnstr_bdd]) option model weak ant cons trace_list
    )
;

let M = 2;          //write port number
let N = 2;          //read port number
let Addr = 4;       //address size
let Depth = 2**4;   //memory depth
let Width=8;        //data size

//write memory definition
//k    : k-th write port(0<= k < m)
//i    : i-th block of (m-1) feedback-write-mem-blocks(0<= i < m-1)
//adr  : write address
//m    : total write port number
//n    : total read port number
//width: data size
let MemoryW k i adr m n width= map (\a. "Memory" ^ ((k*(m-1)+i=0) => "" | ("_"^(int2str (k*(m-1)+i))))
                                        ^".mem<" ^ (int2str adr) ^ "><" ^ (int2str a) ^ ">") (0 upto (width-1))
;

let memW k adr m n width = map (\a. bvariable ("memW<" ^ (int2str k) 
                                 ^"><" ^ (int2str adr) ^ "><" ^ (int2str a) ^ ">")) (0 upto (width-1))
;


//read memory definition
//k    : k-th write port(0<= k < m)
//j    : j-th read port / j-th block of n read-mem-blocks of a write-port(0<= j <n)
//adr  : read address
//m    : total write port number
//n    : total read port number
//width: data size
let MemoryR k j adr m n width= map (\a. "Memory_" ^ (int2str (m*(m-1) + k*n + j)) ^ ".mem<" ^ (int2str adr) ^ "><" ^ (int2str a) ^ ">") (0 upto (width-1))
;

let memR k adr m n width = map (\a. bvariable ("memR<" ^ (int2str k) 
                                 ^"><" ^ (int2str adr) ^ "><" ^ (int2str a) ^ ">")) (0 upto (width-1))
;

//xor2 of two bexpr vectors
let xor2 [] bv2 = bv2
    /\ xor2 bv1 [] = bv1
    /\ xor2 bv1 bv2 =            
            map2 (\i.\j. i bXOR j) bv1 bv2
;

//XOR function of list of bexpr vectors with same length
let XORs bexprVecs = 
    letrec XORs_h [] = []
        /\ XORs_h [x] = [x]
        /\ XORs_h bvs =
            XORs_h ((xor2 (hd bvs) (hd (tl bvs))):(tl (tl bvs)))
    in
    let res = (XORs_h bexprVecs) in
    res=[] => error "Empty Arguments" | (hd res)
;
//let bvs = [[bvariable "x1",bvariable "x2" ], [bvariable "y1", bvariable "y2"], [bvariable "z1", bvariable "z2"], [bvariable "w1", bvariable "w2"]];
//XORs bvs;


//write enable
let we i = "io_wrEna_" ^ (int2str i);

let wrEna k =
    let terms = map (\i. (i=k)=> Is1 ("io_wrEna_" ^ (int2str i)) | Is0 ("io_wrEna_" ^ (int2str i))) (0 upto (M-1)) 
    in
    TAndList terms
;

let nwrEna k =
    let terms = map (\i. (i=k)=> Is0 ("io_wrEna_" ^ (int2str i)) | Is0 ("io_wrEna_" ^ (int2str i))) (0 upto (M-1)) 
    in
    TAndList terms
;

let bEqual belista belistb =
   itlist (\e.\r. e bAND r) (map2 (\a.\b. ((bNOT a) bOR b) bAND ((bNOT b) bOR a)) belista belistb) bT
;

//nodes
let clk2 = TAndList [Is0 "CLK", Next (Is1 "CLK")];
let clk4 = TAndList [Is0 "CLK", Next (Is1 "CLK"), Next (Next (Is0 "CLK")), Next (Next (Next (Is1 "CLK")))];
let rst = Is1 "reset";
let nrst = Is0 "reset";
let wraddr i = map (\j. "io_wrAddr_"^(int2str i) ^ "<" ^ (int2str j) ^ ">") (0 upto (Addr-1)); //write on write-port i
let rdaddr i = map (\j. "io_rdAddr_"^(int2str i) ^ "<" ^ (int2str j) ^ ">") (0 upto (Addr-1)); //read on read-port i
let wrdata i = map (\j. "io_wrData_"^(int2str i) ^ "<" ^ (int2str j) ^ ">") (0 upto (Width-1));
let rddata i = map (\j. "io_rdData_"^(int2str i) ^ "<" ^ (int2str j) ^ ">") (0 upto (Width-1));
//symbolic constants
let vDataIn = map (\i. bvariable ("data"^(int2str i))) (0 upto (Width-1));
let vAddrIn = map (\i. bvariable ("addrV"^(int2str i))) (0 upto (Addr-1));
let vWE = bvariable "wrV";
let memwUnit i j a = MemoryW i j a M N Width;
let memwV i a = memW i a M N Width;
let memrUnit i j a = MemoryR i j a M N Width;
let memrV i a = memR i a M N Width;
//basic assertions
let memwAntAssert adr = TAndList (flat (map (\i. 
                                ( map (\j. (memwUnit i j adr) bvAre (memwV i adr)) (0 upto (M-2)))
                            ) (0 upto (M-1))))
;
let memrAntAssert adr = TAndList (flat (map (\i. 
                                ( map (\j. (memrUnit i j adr) bvAre (memrV i adr)) (0 upto (N-1)))
                            ) (0 upto (M-1))))
;
let memwConsAssert adr  = TAndList (flat (map (\i. 
                                ( map (\j. (memwUnit i j adr) bvAre (memwV i adr)) (0 upto (M-2)))
                            ) (0 upto (M-1))))
;
let memrConsAssert adr = TAndList (flat (map (\i. 
                                ( map (\j. (memrUnit i j adr) bvAre (memrV i adr)) (0 upto (N-1)))
                            ) (0 upto (M-1))))
;
let memwAntAssertNoK k adr = (TAndList (flat (map (\i. 
                                ( map (\j. (memwUnit i j adr) bvAre (memwV i adr)) (0 upto (M-2)))
                            ) (filter (\m. m!=k) (0 upto (M-1))))))
;
let memrAntAssertNoK k adr = (TAndList (flat (map (\i. 
                                ( map (\j. (memrUnit i j adr) bvAre (memrV i adr)) (0 upto (N-1)))
                            ) (filter (\i. i!=k) (0 upto (M-1))))))
;
// get all feedback to writePort k, defaultly retrieve other ports' first (0) feedback block
// 0 <= k < M, 0 <= fi < M-1
let feedbackw k fi adr = XORs (map (\wp. memwV wp adr) (filter (\i. i!=k) (0 upto (M-1))));
let memwConsAssertOnK K adr=Next (TAndList (map (\fbi. (memwUnit K fbi adr) bvAre (XORs [feedbackw K 0 adr, vDataIn])) (0 upto (M-2))));
// 0 <= k < M, 0 <= n < N
let feedbackr k n adr = XORs (map (\p. memrV p adr) (filter (\i. i!=k) (0 upto (M-1))));
let memrConsAssertOnK K adr =Next (TAndList (map (\n. (memrUnit K n adr) bvAre (XORs [feedbackr K n adr, vDataIn])) (0 upto (N-1))));


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//edge 0->1 (write on port K, address adr)
//test all (M-1) feedback write blocks and all (N) read blocks related to write-port K
let test1 K adr =
    //antecedent and consequent
    let ant_t = TAndList [memwAntAssertNoK K adr, Next (memwAntAssertNoK K adr), Next (Next (memwAntAssertNoK K adr)),
                        memrAntAssertNoK K adr, Next (memrAntAssertNoK K adr), Next (Next (memrAntAssertNoK K adr)),
                        addrIs (wraddr K) adr, Next (addrIs (wraddr K) adr), Next (Next (addrIs (wraddr K) adr)),
                        wrEna K, Next (wrEna K), Next (Next (wrEna K)),
                        (wrdata K) bvAre vDataIn, Next ((wrdata K) bvAre vDataIn), Next (Next ((wrdata K) bvAre vDataIn)), 
                        nrst, Next (nrst), Next (Next (nrst)),
                        clk4] in
    let cons_t = TAndList [Next (Next (memwConsAssertOnK K adr)), Next (Next (memrConsAssertOnK K adr))] in
    let cnstr = flat (map (\wp. 
                        (map (\a. 
                                bEqual (memwV wp a) (memrV wp a)) 
                        (0 upto (Depth-1))))
                    (0 upto (M-1))
                )
    in
    let ant = trajForm2FiveTuples ant_t in
    let cons = trajForm2FiveTuples cons_t in
    uSTE "" ckt [] ant cons [] cnstr => T | F 
;

//edge 1 -> 1 (write on port K, address adr)
let test2 K adr =
    //xor of all write-port blocks with same feedback block position
    let xorsOfW fi = XORs (map (\wp. memwV wp adr) (0 upto (M-1))) in
    let cnstrOnW = map (\fi. bEqual (xorsOfW fi) vDataIn) (0 upto (M-2)) in
    //xor of all write-port blocks with same read-port position
    let xorsOfR rp = XORs (map (\wp. memrV wp adr) (0 upto (M-1))) in
    let cnstrOnR = map (\rp. bEqual (xorsOfR rp) vDataIn) (0 upto (N-1)) in
    //no-write and write-address constraint
    let ena i = Isb vWE (we i) in
    let addr i = (wraddr i) bvAre vAddrIn in
    let enaAndAddr i = TAndList [Isb vWE (we i), (wraddr i) bvAre vAddrIn] in
    let EA = TAndList (map (\i. enaAndAddr i) (0 upto (M-1))) in
    let cnstr_EA = (bNOT vWE) bOR (bNOT (isI vAddrIn adr)) in 
    //antecedent and consequent
    let ant_t = TAndList [memwAntAssert adr, memrAntAssert adr, nrst, Next (nrst), EA, Next (EA), clk2] in
    let cons_t = TAndList [memwConsAssert adr, memrConsAssert adr] in
    let ant = trajForm2FiveTuples ant_t in
    let cons = trajForm2FiveTuples cons_t in
    uSTE "" ckt [] ant cons [] (cnstr_EA:(cnstrOnW@cnstrOnR)) => T | F 
;

let test3 L adr =
    //xor of all write-ports with same feedback block position
    let xorsOfW fi= XORs (map (\wp. memwV wp adr) (0 upto (M-1))) in
    let cnstrOnW = map (\fi. bEqual (xorsOfW fi) vDataIn) (0 upto (M-2)) in
    //xor of all write-ports with same read-port position
    let xorsOfR rp = XORs (map (\wp. memrV wp adr) (0 upto (M-1))) in
    let cnstrOnR = map (\rp. bEqual (xorsOfR rp) vDataIn) (0 upto (N-1)) in
    //antecedent and consequent
    let ant_t = TAndList [memwAntAssert adr, Next (memwAntAssert adr), 
                        memrAntAssert adr, Next (memrAntAssert adr), 
                        addrIs (rdaddr L) adr, Next (addrIs (rdaddr L) adr), 
                        nrst, Next (nrst), 
                        clk2] in
    let cons_t = Next ((rddata L) bvAre vDataIn) in
    let ant = trajForm2FiveTuples ant_t in
    let cons = trajForm2FiveTuples cons_t in
    uSTE "" ckt [] ant cons [] (cnstrOnW@cnstrOnR) => T | F 
;

itlist (\i.\r1. 
        (itlist (\j.\r2. 
                (test3 i j) AND r2)  
            (0 upto (Depth-1)) T ) AND r1)
        (0 upto (N-1)) T
;

itlist (\i.\r1. 
        (itlist (\j.\r2. 
                (test2 i j) AND r2)  
            (0 upto (Depth-1)) T ) AND r1)
        (0 upto (M-1)) T
;

itlist (\i.\r1. 
        (itlist (\j.\r2. 
                (test1 i j) AND r2)  
            (0 upto (Depth-1)) T ) AND r1)
        (0 upto (M-1)) T
;

quit;
