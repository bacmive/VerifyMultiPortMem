let ckt = load_exe "OneHotCodeILvtMultiPortMemory32.exe";
load "gsteSymReduce.fl";
loadModel ckt;

let isI addrV i=
    let ADDR_SIZE = length addrV in 
    let ivec = ind2Addr i ADDR_SIZE in
    let terms = map2 (\a. \iv. iv=bT =>  a | bNOT a) addrV ivec in
    itlist (\t.\pre. (t bAND pre)) terms bT
;

let addrIs adr n= 
    let size = length adr 
    in
	letrec tobool n size=
		(size = 0) => []
		| (n%2): (tobool (n/2) (size-1)) 
    in
	TAndList (map2 (\i.\j. (i=0) => (Is0 (el (j+1) adr)) | (Is1 (el (j+1) adr))) (tobool n size) (0 upto (size-1)))
;

//universal STE
let uSTE option model weak ant cons trace_list constraints =
    constraints = [] => (
       STE option model weak ant cons trace_list
    ) | (
        let all_cnstr = itlist (\c.\pre. c bAND pre) constraints bT in
        let cnstr_bdd = hd (bexpr2bdd [] [all_cnstr]) in
        cSTE ([], [cnstr_bdd]) option model weak ant cons trace_list
    )
;

let M = 3;          //write port number
let N = 2;          //read port number
let Addr = 4;       //address size
let Depth = 2**4;   //memory depth
let Width=8;        //data size

//write mutex signal and write memory definition
//k    : k-th write port(0<= k < m)
//i    : i-th block of (m-1) feedback-read-mem-blocks(0<= i < m-1)
//adr  : write address
//m    : total write port number
//n    : total read port number
//width: data size
let MutexW k i adr m n = map (\a. "Memory" ^ ((k*(m-1)+i=0) => "" | ("_"^(int2str (k*(m-1)+i))))
                                        ^".mem<" ^ (int2str adr) ^ "><" ^ (int2str a) ^ ">") (0 upto (m-2))
;

let MemoryW k i adr m n width= map (\a. "Memory" ^ ((k*(m-1)+i=0) => "" | ("_"^(int2str (k*(m-1)+i))))
                                        ^".mem<" ^ (int2str adr) ^ "><" ^ (int2str a) ^ ">") (m-1 upto (m+width-2))
;

//symbolic values
let muxW k adr m n = map (\a. bvariable ("muxW<" ^ (int2str k) 
                                 ^"><" ^ (int2str adr) ^ "><" ^ (int2str a) ^ ">")) (0 upto (m-2))
;

let memW k adr m n width = map (\a. bvariable ("memW<" ^ (int2str k) 
                                 ^"><" ^ (int2str adr) ^ "><" ^ (int2str a) ^ ">")) (m-1 upto (m+width-2))
;


//read mutex signal and read memory definition
//k    : k-th write port(0<= k < m)
//j    : j-th read port / j-th block of n read-mem-blocks of a write-port(0<= j <n)
//adr  : read address
//m    : total write port number
//n    : total read port number
//width: data size
let MutexR k j adr m n = map (\a. "Memory_" ^ (int2str (m*(m-1) + k*n + j)) ^ ".mem<" ^ (int2str adr) ^ "><" ^ (int2str a) ^ ">") (0 upto (m-2)) // (m-1) bits for mutex
;

let MemoryR k j adr m n width= map (\a. "Memory_" ^ (int2str (m*(m-1) + k*n + j)) ^ ".mem<" ^ (int2str adr) ^ "><" ^ (int2str a) ^ ">") (m-1 upto (m+width-2))
;
//symbolic values
let muxR k adr m n = map (\a. bvariable ("muxR<" ^ (int2str k) 
                                 ^"><" ^ (int2str adr) ^ "><" ^ (int2str a) ^ ">")) (0 upto (m-2))
;

let memR k adr m n width = map (\a. bvariable ("memR<" ^ (int2str k) 
                                 ^"><" ^ (int2str adr) ^ "><" ^ (int2str a) ^ ">")) (m-1 upto (m+width-2))
;

//xor2 of two bexpr vectors
let xor2 [] bv2 = bv2
    /\ xor2 bv1 [] = bv1
    /\ xor2 bv1 bv2 =            
            map2 (\i.\j. i bXOR j) bv1 bv2
;

//XOR function of list of bexpr vectors with same length
let XORs bexprVecs = 
    letrec XORs_h [] = []
        /\ XORs_h [x] = [x]
        /\ XORs_h bvs =
            XORs_h ((xor2 (hd bvs) (hd (tl bvs))):(tl (tl bvs)))
    in
    let res = (XORs_h bexprVecs) in
    res=[] => error "Empty Arguments" | (hd res)
;
//let bvs = [[bvariable "x1",bvariable "x2" ], [bvariable "y1", bvariable "y2"], [bvariable "z1", bvariable "z2"], [bvariable "w1", bvariable "w2"]];
//XORs bvs;


//write enable signals
let we i = "io_wrEna_" ^ (int2str i);

let wrEna k =
    let terms = map (\i. (i=k)=> Is1 ("io_wrEna_" ^ (int2str i)) | Is0 ("io_wrEna_" ^ (int2str i))) (0 upto (M-1)) 
    in
    TAndList terms
;

let nwrEna k =
    let terms = map (\i. (i=k)=> Is0 ("io_wrEna_" ^ (int2str i)) | Is0 ("io_wrEna_" ^ (int2str i))) (0 upto (M-1)) 
    in
    TAndList terms
;

//equation of 2 bdd expressions
let bEqual bea beb =
    ((bNOT bea) bOR beb) bAND ((bNOT beb) bOR bea)
;
//equation of 2 bdd expression lists
let bEquals belista belistb =
   itlist (\e.\r. e bAND r) (map2 (\a.\b. ((bNOT a) bOR b) bAND ((bNOT b) bOR a)) belista belistb) bT
;

//nodes
let clk2 = TAndList [Is0 "CLK", Next (Is1 "CLK")];
let clk4 = TAndList [Is0 "CLK", Next (Is1 "CLK"), Next (Next (Is0 "CLK")), Next (Next (Next (Is1 "CLK")))];
let rst = Is1 "reset";
let nrst = Is0 "reset";
let wraddr i = map (\j. "io_wrAddr_"^(int2str i) ^ "<" ^ (int2str j) ^ ">") (0 upto (Addr-1)); //write on write-port i
let rdaddr i = map (\j. "io_rdAddr_"^(int2str i) ^ "<" ^ (int2str j) ^ ">") (0 upto (Addr-1)); //read on read-port i
let wrdata i = map (\j. "io_wrData_"^(int2str i) ^ "<" ^ (int2str j) ^ ">") (0 upto (Width-1));
let rddata i = map (\j. "io_rdData_"^(int2str i) ^ "<" ^ (int2str j) ^ ">") (0 upto (Width-1));
//symbolic constants
let vDataIn = map (\i. bvariable ("data"^(int2str i))) (0 upto (Width-1));
let vAddrIn = map (\i. bvariable ("addrV"^(int2str i))) (0 upto (Addr-1));
let vWE = bvariable "wrV";

let muxwUnit i j a = MutexW i j a M N;
let memwUnit i j a = MemoryW i j a M N Width;
let muxwV i a = muxW i a M N;
let memwV i a = memW i a M N Width;
let muxwCell k j a i =  el (i+1) (muxwUnit k j a);
let muxwCellV k a i =  el (i+1) (muxwV k a);

let muxrUnit i j a = MutexR i j a M N;
let memrUnit i j a = MemoryR i j a M N Width;
let muxrV i a = muxR i a M N;
let memrV i a = memR i a M N Width;
let muxrCell k j a i =  el (i+1) (muxrUnit k j a);
let muxrCellV k a i =  el (i+1) (muxrV k a);

//basic assertions
let memwAntAssertNoK k adr = (TAndList (flat (map (\i. 
                                ( map (\j.(muxwUnit i j adr) bvAre (muxwV i adr)) (0 upto (M-2)))
                            ) (filter (\m. m!=k) (0 upto (M-1))))))
;
let memrAntAssertNoK k adr = (TAndList (flat (map (\i. 
                                ( map (\j. (muxrUnit i j adr) bvAre (muxrV i adr)) (0 upto (N-1)))
                            ) (filter (\i. i!=k) (0 upto (M-1))))))
;


//k: write-port, adr:write-address, i: mutex-position(0<=i<(m-1)), j: feedback-block-index(0<=j<(m-1)), correspond to paper def
let muxwAssert k adr = 
    let cellValAti i = (i<k => bNOT (muxwCellV i adr (k-1)) | (muxwCellV (i+1) adr k)) in
    let assertOnBlockj j = TAndList (map (\i. Isb  (cellValAti i) (muxwCell k j adr i)) (0 upto (M-2))) in
    TAndList (map (\j. assertOnBlockj j) (0 upto (M-2)))
;

//k: write-port, adr:write-address, i: mutex-position(0<=i<(m-1)), j: feedback-block-index(0<=j<(m-1)), correspond to paper def
let muxrAssert k adr = 
    let cellValAti i = (i<k => bNOT (muxrCellV i adr (k-1)) | (muxrCellV (i+1) adr k)) in
    let assertOnBlockj j = TAndList (map (\i. Isb  (cellValAti i) (muxrCell k j adr i)) (0 upto (M-2))) in
    TAndList (map (\j. assertOnBlockj j) (0 upto (N-1)))
;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//edge 0->1 (write on port K, address adr)
//test all (M-1) feedback write blocks and all (N) read blocks related to write-port K
let test1 K adr =
    let wconsAssert = TAndList (map (\j. (memwUnit K j adr) bvAre vDataIn) (0 upto (M-2))) in
    let rconsAssert = TAndList (map (\j. (memrUnit K j adr) bvAre vDataIn) (0 upto (M-2))) in
    //antecedent and consequent
    let ant_t = TAndList [memwAntAssertNoK K adr, Next (memwAntAssertNoK K adr), Next (Next (memwAntAssertNoK K adr)),
                        memrAntAssertNoK K adr, Next (memrAntAssertNoK K adr), Next (Next (memrAntAssertNoK K adr)),
                        addrIs (wraddr K) adr, Next (addrIs (wraddr K) adr), Next (Next (addrIs (wraddr K) adr)),
                        wrEna K, Next (wrEna K), Next (Next (wrEna K)),
                        (wrdata K) bvAre vDataIn, Next ((wrdata K) bvAre vDataIn), Next (Next ((wrdata K) bvAre vDataIn)), 
                        nrst, Next (nrst), Next (Next (nrst)),
                        clk4] in
    let cons_t = TAndList [Next (Next (Next (TAndList [wconsAssert, rconsAssert, muxwAssert K adr, muxrAssert K adr])))] in
    let ant = trajForm2FiveTuples ant_t in
    let cons = trajForm2FiveTuples cons_t in
    let cnstr1 = flat (map (\wp. 
                        (map (\a. 
                                bEquals (memwV wp a) (memrV wp a)) 
                        (0 upto (Depth-1))))
                    (0 upto (M-1))
                )
    in
    let cnstr2 = flat (map (\wp. 
                        (map (\a. 
                                bEquals (muxwV wp a) (muxrV wp a)) 
                        (0 upto (Depth-1))))
                    (0 upto (M-1))
                )
    in
    let tls = [("Memory_1.mem<5><0>", 0, 4), ("Memory_1.mem<5><1>", 0, 4)] in
    uSTE "" ckt [] ant cons [] (cnstr1@cnstr2) => T | F 
;


let test2 K adr =
    let memwAntAssert = TAndList (flat (map (\i. 
                                    ( map (\j. TAndList [(memwUnit i j adr) bvAre (memwV i adr),
                                                        (muxwUnit i j adr) bvAre (muxwV i adr)]
                                    ) (0 upto (M-2)))
                                ) (0 upto (M-1))))
    in
    let memrAntAssert = TAndList (flat (map (\i. 
                                    ( map (\j. TAndList [(memrUnit i j adr) bvAre (memrV i adr),
                                                        (muxrUnit i j adr) bvAre (muxrV i adr)]
                                    ) (0 upto (N-1)))
                                ) (0 upto (M-1))))
    in
    let memwConsAssert = TAndList (flat (map (\i. 
                                    ( map (\j. TAndList [(memwUnit i j adr) bvAre (memwV i adr),
                                                        (muxwUnit i j adr) bvAre (muxwV i adr)]
                                    ) (0 upto (M-2)))
                                ) (0 upto (M-1))))
    in
    let memrConsAssert = TAndList (flat (map (\i. 
                                    ( map (\j. TAndList [(memrUnit i j adr) bvAre (memrV i adr),
                                                        (muxrUnit i j adr) bvAre (muxrV i adr)]
                                    ) (0 upto (N-1)))
                                ) (0 upto (M-1))))
    in
    //no-write and write-address constraint
    let ena i = Isb vWE (we i) in
    let addr i = (wraddr i) bvAre vAddrIn in
    let enaAndAddr i = TAndList [Isb vWE (we i), (wraddr i) bvAre vAddrIn] in
    let EA = TAndList (map (\i. enaAndAddr i) (0 upto (M-1))) in
    let cnstr_EA = (bNOT vWE) bOR (bNOT (isI vAddrIn adr)) in 
    //ants and cons
    let ant_t = TAndList [memwAntAssert, memrAntAssert, nrst, Next (nrst), EA, Next (EA), clk2] in
    let cons_t = TAndList [memwConsAssert, memrConsAssert] in
    let ant = trajForm2FiveTuples ant_t in
    let cons = trajForm2FiveTuples cons_t in
    uSTE "" ckt [] ant cons [] [cnstr_EA] => T | F 
;
    
let test3 K R adr =
    let memrAntAssert = TAndList (map (\j. (memrUnit K j adr) bvAre vDataIn) (0 upto (N-1))) in
    let muxrAntAssert = (TAndList (flat (map (\i. 
                                    (map (\j. (muxrUnit i j adr) bvAre (muxrV i adr)) (0 upto (N-1)))
                                ) (0 upto (M-1)))))
    in
    //constraints
    let rcellValAti i = (i<K => bNOT (muxrCellV i adr (K-1)) | (muxrCellV (i+1) adr K)) in
    let cnstr = map (\i. bEqual (muxrCellV K adr i) (rcellValAti i)) (0 upto (M-2)) in
    let cnstr1 = map (\i. bEqual (muxrCellV K adr i) bF ) (0 upto (M-2)) in
    //antecedent and consequent
    let ant_t = TAndList [memrAntAssert, Next (memrAntAssert), 
                        muxrAntAssert, Next (muxrAntAssert),
                        addrIs (rdaddr R) adr, Next (addrIs (rdaddr R) adr), 
                        nwrEna K, Next (nwrEna K),
                        nrst, Next (nrst), 
                        clk2] in
    let cons_t =Next ((rddata R) bvAre vDataIn) in
    let ant = trajForm2FiveTuples ant_t in
    let cons = trajForm2FiveTuples cons_t in
    uSTE "" ckt [] ant cons [] (cnstr@cnstr1) => T | F 
;

itlist (\i.\r1. 
        (itlist (\j.\r2. 
                (test1 i j) AND r2)  
            (0 upto (Depth-1)) T ) AND r1)
        (0 upto (M-1)) T
;

itlist (\i.\r1. 
        (itlist (\j.\r2. 
                (test2 i j) AND r2)  
            (0 upto (Depth-1)) T ) AND r1)
        (0 upto (M-1)) T
;

itlist (\i.\r1. 
        (itlist (\j.\r2. 
                      (itlist (\a.\r3.
                          (test3 i j a) AND r3)
                  (0 upto (Depth-1)) T) AND r2)
            (0 upto (N-1)) T ))
        (0 upto (M-1)) T
;
quit;
